#!/usr/bin/perl

use strict;
use warnings;

use Data::Dumper;
use File::Basename;
use File::Find;
use File::Slurp;    # perl-File-Slurp
use Getopt::Long;

my %sysfs;

my $usage = <<EOF;

- Configure vdev_id.conf(5)

    encctl --configure | tee /etc/zfs/vdev_id.conf.tmp
    diff -u /etc/zfs/vdev_id.conf{,.tmp} # if necessary
    mv /etc/zfs/vdev_id.conf{.tmp,}
    udevadm trigger
    ls -l /dev/disk/by-path

- Show expander topology

    encctl --topology

- Show slot status

    encctl --show

- Show S.M.A.R.T attribute

    encctl --smart

- Locate a disk drive on an enclosure

    encctl --locate 3:0:0       # locate 3:0:0
    encctl --locate 3:0         # locate 3:0:*
    encctl --locate all         # locate *:*:*
    encctl --locate_off 3:0:0   # unlocate 3:0:0
    encctl --locate_off 3:0     # unlocate 3:0:*
    encctl --locate_off all     # unlocate *:*:*

EOF

sub sort_alias {
    return sort { ( split /:/, $a )[0] <=> ( split /:/, $b )[0] }
        sort    { ( split /:/, $a )[1] <=> ( split /:/, $b )[1] }
        sort    { ( split /:/, $a )[2] <=> ( split /:/, $b )[2] } @_;
}

sub prepare {
    m{^Slot (\d+)\z} or return;
    my $slot = $1 - 1;    # backplane's slot number began 0
    $File::Find::dir =~ m{0000:0*(\d+):00\.0/host\d+/.*/expander-\d+:(\d+)} or return;
    my $enc = "$1:$2";
    $sysfs{"$enc:$slot"} = $File::Find::name;
}

sub topology {
    $File::Find::name =~ m{/port-[\d:]+/expander-[\d:]+\z} or return;
    my @topology = $File::Find::name =~ m{/expander-([\d:]+)}g
        or return;
    print join( " -> ", @topology ), "\n";
}

my %opt;

GetOptions(
    "configure"        => \$opt{configure},
    "topology"         => \$opt{topology},
    "show"             => \$opt{show},
    "smart"            => \$opt{smart},
    "locate=s{1,}"     => \@{ $opt{locate} },
    "locate_off=s{1,}" => \@{ $opt{locate_off} },
) or die("$usage");

{
    my @check;
    foreach ( sort keys %opt ) {
        if ( ref $opt{$_} ) {
            push @check, $_ if @{ $opt{$_} } > 0;
        }
        elsif ( defined $opt{$_} ) {
            push @check, $_;
        }
    }
    if ( @check > 1 ) {
        die sprintf "$0: multiple option [%s] specifed.\n", join ", ", @check;
    }
}

if ( $opt{configure} ) {
    find( \&prepare, "/sys/devices" );
    foreach ( sort_alias keys %sysfs ) {
        my $pci = ( split m{/}, $sysfs{$_} )[5];
        chomp( my $sas_address = read_file("$sysfs{$_}/device/sas_address") );
        printf "alias %s\tpci-%s-sas-%s-lun-0\n", $_, $pci, $sas_address;
    }
}
elsif ( $opt{topology} ) {
    find( \&topology, "/sys/devices" );
}
elsif ( $opt{show} ) {
    find( \&prepare, "/sys/devices" );
    foreach ( sort_alias keys %sysfs ) {
        chomp( my $active = read_file("$sysfs{$_}/active") );
        chomp( my $fault  = read_file("$sysfs{$_}/fault") );
        chomp( my $locate = read_file("$sysfs{$_}/locate") );
        chomp( my $status = read_file("$sysfs{$_}/status") );
        printf "%s\tactive => %s\tfault => %s\tlocate => %s\tstatus => %s\n",
            $_, $active, $fault, $locate, $status;
    }
}
elsif ( $opt{smart} ) {
    find( \&prepare, "/sys/devices" );
    my @target
        = qw/Reallocated_Sector_Ct Reported_Uncorrect Command_Timeout Current_Pending_Sector Offline_Uncorrectable/;
    print "NAME\t", join " ", @target, "\n";
    foreach ( sort_alias keys %sysfs ) {
        if ( opendir my $dh, "$sysfs{$_}/device/block" ) {
            my ($dev) = grep {/^sd/} readdir $dh or next;
            chomp( my @smartctl = qx{smartctl -A /dev/$dev 2> /dev/null} );
            map {s/^\s+//} @smartctl;
            my %attr = map { ( split /\s+/, $_, 10 )[ 1, 9 ] } @smartctl;
            print "$_\t";
            foreach my $target (@target) {
                print defined $attr{$target} ? $attr{$target} : "N/A";
                print " " x (
                    1 + length($target) - length(
                        defined $attr{$target} ? $attr{$target} : "N/A"
                    )
                );
            }
            print "\n";
        }
    }
}
elsif ( @{ $opt{locate} } ) {
    my @target;
    find( \&prepare, "/sys/devices" );
    foreach ( @{ $opt{locate} } ) {
        my $quotemeta = quotemeta;
        if ( exists $sysfs{$_} ) {
            push @target, $_;
        }
        elsif ( grep {/^$quotemeta:/} keys %sysfs ) {
            push @target, grep {/^$quotemeta:/} sort_alias keys %sysfs;
        }
        elsif ( $_ eq 'all' ) {
            @target = sort_alias keys %sysfs;
            last;
        }
        else {
            die "$_ is not exists\n";
        }
    }
    foreach (@target) {
        my $filename = "$sysfs{$_}/locate";
        if ( write_file( $filename, 1 ) ) {
            print "$_ => 1\n";
        }
        else {
            print STDERR "Can't write to $filename\n";
        }
    }
}
elsif ( @{ $opt{locate_off} } ) {
    my @target;
    find( \&prepare, "/sys/devices" );
    foreach ( @{ $opt{locate_off} } ) {
        my $quotemeta = quotemeta;
        if ( exists $sysfs{$_} ) {
            push @target, $_;
        }
        elsif ( grep {/^$quotemeta:/} keys %sysfs ) {
            push @target, grep {/^$quotemeta:/} sort_alias keys %sysfs;
        }
        elsif ( $_ eq 'all' ) {
            @target = sort_alias keys %sysfs;
            last;
        }
        else {
            die "$_ is not exists\n";
        }
    }
    foreach (@target) {
        my $filename = "$sysfs{$_}/locate";
        if ( write_file( $filename, 0 ) ) {
            print "$_ => 0\n";
        }
        else {
            print STDERR "Can't write to $filename\n";
        }
    }
}
else {
    print $usage;
}
