#!/usr/bin/perl

use strict;
use warnings;

use Data::Dumper;
use File::Basename;
use File::Find;
use File::Slurp;              # perl-File-Slurp
use Getopt::Long;
use Parallel::ForkManager;    # perl-Parallel-ForkManager
use Term::ANSIColor qw(:constants);

my %sysfs;

my $usage = <<EOF;

- Configure vdev_id.conf(5)

    encctl --configure | tee /etc/zfs/vdev_id.conf.tmp
    diff -u /etc/zfs/vdev_id.conf{,.tmp} # if necessary
    mv /etc/zfs/vdev_id.conf{.tmp,}
    udevadm trigger
    ls -l /dev/disk/by-path

- Show expander topology

    encctl --topology

- Show slot status

    encctl --show

- Show S.M.A.R.T attribute

    encctl --smart

- Show S.M.A.R.T error log in N days.

    encctl --smarterror N

- Locate a disk drive on an enclosure

    encctl --locate 3:0:0       # locate 3:0:0
    encctl --locate 3:0         # locate 3:0:*
    encctl --locate all         # locate *:*:*
    encctl --locate_off 3:0:0   # unlocate 3:0:0
    encctl --locate_off 3:0     # unlocate 3:0:*
    encctl --locate_off all     # unlocate *:*:*

EOF

sub sort_alias {
    return sort { ( split /:/, $a )[0] <=> ( split /:/, $b )[0] }
        sort    { ( split /:/, $a )[1] <=> ( split /:/, $b )[1] }
        sort    { ( split /:/, $a )[2] <=> ( split /:/, $b )[2] } @_;
}

sub prepare {
    m{^Slot (\d+)\z} or return;
    my $slot = $1 - 1;    # backplane's slot number began 0
    $File::Find::dir =~ m{0000:0*(\d+):00\.0/host\d+/.*/expander-\d+:(\d+)} or return;
    my $enc = "$1:$2";
    $sysfs{"$enc:$slot"} = $File::Find::name;
}

sub topology {
    $File::Find::name =~ m{/port-[\d:]+/expander-[\d:]+\z} or return;
    my @topology = $File::Find::name =~ m{/expander-\d:([\d:]+)}g or return;
    my ($bus) = $File::Find::name =~ m{/0000:0*(\d+):00\.0/host\d+/} or return;
    map {s/^/$bus:/} @topology;
    print join( " -> ", @topology ), "\n";
}

my %opt;

GetOptions(
    "configure"        => \$opt{configure},
    "topology"         => \$opt{topology},
    "show"             => \$opt{show},
    "smart"            => \$opt{smart},
    "smarterror=i"     => \$opt{smarterror},
    "locate=s{1,}"     => \@{ $opt{locate} },
    "locate_off=s{1,}" => \@{ $opt{locate_off} },
) or die("$usage");

{
    my @check;
    foreach ( sort keys %opt ) {
        if ( ref $opt{$_} ) {
            push @check, $_ if @{ $opt{$_} } > 0;
        }
        elsif ( defined $opt{$_} ) {
            push @check, $_;
        }
    }
    if ( @check > 1 ) {
        die sprintf "$0: multiple option [%s] specifed.\n", join ", ", @check;
    }
}

if ( $opt{configure} ) {
    find( \&prepare, "/sys/devices" );
    foreach ( sort_alias keys %sysfs ) {
        my $pci = ( split m{/}, $sysfs{$_} )[5];
        chomp( my $sas_address = read_file("$sysfs{$_}/device/sas_address") );
        printf "alias %s\tpci-%s-sas-%s-lun-0\n", $_, $pci, $sas_address;
    }
}
elsif ( $opt{topology} ) {
    find( \&topology, "/sys/devices" );
}
elsif ( $opt{show} ) {
    find( \&prepare, "/sys/devices" );
    foreach ( sort_alias keys %sysfs ) {
        chomp( my $active = read_file("$sysfs{$_}/active") );
        chomp( my $fault  = read_file("$sysfs{$_}/fault") );
        chomp( my $locate = read_file("$sysfs{$_}/locate") );
        chomp( my $status = read_file("$sysfs{$_}/status") );
        printf "%s\tactive => %s\tfault => %s\tlocate => %s\tstatus => %s\n",
            $_, $active, $fault, $locate, $status;
    }
}
elsif ( $opt{smart} ) {
    find( \&prepare, "/sys/devices" );

    my $pm = Parallel::ForkManager->new(8);
    my %SMART_Attributes;
    $pm->run_on_finish(
        sub { %SMART_Attributes = ( %SMART_Attributes, @_[ 2, 5 ] ) } );
    $pm->run_on_start( sub { printf STDERR "Checking %s\n", $_[1] } );
    foreach ( sort_alias keys %sysfs ) {
        opendir my $dh, "$sysfs{$_}/device/block" or next;
        my ($dev) = grep {/^sd/} readdir $dh or next;

        # Forks and returns the pid for the child:
        my $pid = $pm->start($_) and next;
        chomp( my @smartctl = qx{exec smartctl -A /dev/$dev 2> /dev/null} );
        $pm->finish( $?, \@smartctl );    # Terminates the child process
    }
    $pm->wait_all_children;

    my @target
        = qw/Reallocated_Sector_Ct Reported_Uncorrect Command_Timeout Current_Pending_Sector Offline_Uncorrectable/;
    print "NAME\t", join " ", @target, "\n";
    foreach ( sort_alias keys %SMART_Attributes ) {
        map {s/^\s+//} @{ $SMART_Attributes{$_} };
        my %attr = map { ( split /\s+/, $_, 10 )[ 1, 9 ] }
            @{ $SMART_Attributes{$_} };
        print "$_\t";
        foreach my $target (@target) {
            my $value = defined $attr{$target} ? $attr{$target} : "N/A";
            if ( -t STDOUT && $attr{$target} ) {
                print BOLD $value, RESET;
            }
            else {
                print $value;
            }
            print " " x ( 1 + length($target) - length($value) );
        }
        print "\n";
    }
}

elsif ( $opt{smarterror} ) {
    find( \&prepare, "/sys/devices" );

    my $pm = Parallel::ForkManager->new(8);
    my %output;
    $pm->run_on_finish( sub { %output = ( %output, @_[ 2, 5 ] ) } );
    $pm->run_on_start( sub { printf STDERR "Checking %s\n", $_[1] } );

    foreach ( sort_alias keys %sysfs ) {
        opendir my $dh, "$sysfs{$_}/device/block" or next;
        my ($dev) = grep {/^sd/} readdir $dh or next;

        # Forks and returns the pid for the child:
        my $pid      = $pm->start($_) and next;
        my $cmd      = "smartctl -i -A -l error /dev/$dev";
        my @output   = ("$_\t$cmd\n");
        my @smartctl = qx{$cmd 2> /dev/null};
        if ( $? >> 8 && 2**6 ) {
            push @output, "\n";
            map {s/^/\t/mg} @smartctl;
            my ( $pow, $echo );
            foreach (@smartctl) {
                if (/^\t(?:Device Model|Serial Number):/) {
                    push @output, $_;
                    next;
                }
                if (/Power_On_Hours.*\s(\d+)/) {
                    $pow = $1;
                    push @output,
                        sprintf "\n\tPower_On_Hours: %d hours (%d days + %d hours)\n\n",
                        $pow, $pow / 24, $pow % 24;
                    next;
                }
                if (/power-on lifetime: (\d+) hours/) {
                    if ( $1 > $pow - 24 * $opt{smarterror} ) {
                        $echo = 1;
                    }
                    else {
                        $echo = 0;
                    }
                }
                push @output, $_ if $echo;
            }
            splice @output, 1, unless grep {/power-on lifetime:/} @output;
        }
        $pm->finish( $?, \@output );    # Terminates the child process
    }
    $pm->wait_all_children;

    foreach ( sort_alias keys %output ) {
        print @{ $output{$_} };
    }
}
elsif ( @{ $opt{locate} } ) {
    my @target;
    find( \&prepare, "/sys/devices" );
    foreach ( @{ $opt{locate} } ) {
        my $quotemeta = quotemeta;
        if ( exists $sysfs{$_} ) {
            push @target, $_;
        }
        elsif ( grep {/^$quotemeta:/} keys %sysfs ) {
            push @target, grep {/^$quotemeta:/} sort_alias keys %sysfs;
        }
        elsif ( $_ eq 'all' ) {
            @target = sort_alias keys %sysfs;
            last;
        }
        else {
            die "$_ is not exists\n";
        }
    }
    foreach (@target) {
        my $filename = "$sysfs{$_}/locate";
        if ( write_file( $filename, 1 ) ) {
            print "$_ => 1\n";
        }
        else {
            print STDERR "Can't write to $filename\n";
        }
    }
}
elsif ( @{ $opt{locate_off} } ) {
    my @target;
    find( \&prepare, "/sys/devices" );
    foreach ( @{ $opt{locate_off} } ) {
        my $quotemeta = quotemeta;
        if ( exists $sysfs{$_} ) {
            push @target, $_;
        }
        elsif ( grep {/^$quotemeta:/} keys %sysfs ) {
            push @target, grep {/^$quotemeta:/} sort_alias keys %sysfs;
        }
        elsif ( $_ eq 'all' ) {
            @target = sort_alias keys %sysfs;
            last;
        }
        else {
            die "$_ is not exists\n";
        }
    }
    foreach (@target) {
        my $filename = "$sysfs{$_}/locate";
        if ( write_file( $filename, 0 ) ) {
            print "$_ => 0\n";
        }
        else {
            print STDERR "Can't write to $filename\n";
        }
    }
}
else {
    print $usage;
}
